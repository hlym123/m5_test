# CST3530



添加组件 [esp_lcd_touch_cst353]()

```shell
 
```

初始化 

```c
 
```

```c
/*
 * SPDX-FileCopyrightText: 2015-2024 Espressif Systems (Shanghai) CO LTD
 * SPDX-FileCopyrightText: 2025 Waveshare
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <stdio.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_system.h"
#include "esp_err.h"
#include "esp_log.h"
#include "esp_check.h"
#include "driver/gpio.h"
#include "esp_lcd_panel_io.h"
#include "esp_lcd_touch.h"
#include "esp_lcd_touch_cst353.h"

static const char *TAG = "CST353";

#define CST353_MAX_TOUCH_POINTS 5

/*******************************************************************************
 * Function definitions
 *******************************************************************************/
static esp_err_t esp_lcd_touch_cst353_read_data(esp_lcd_touch_handle_t tp);
static bool esp_lcd_touch_cst353_get_xy(esp_lcd_touch_handle_t tp, uint16_t *x, uint16_t *y, uint16_t *strength,
                                        uint8_t *point_num, uint8_t max_point_num);
static esp_err_t esp_lcd_touch_cst353_del(esp_lcd_touch_handle_t tp);
static esp_err_t cst353_reset(esp_lcd_touch_handle_t tp);
static esp_err_t cst353_write_reg_nd(esp_lcd_touch_handle_t tp, uint32_t reg, size_t reg_len);
static esp_err_t cst353_read_reg(esp_lcd_touch_handle_t tp, uint32_t reg, size_t reg_len, uint8_t *read_buf,
                                 size_t read_len);
static esp_err_t cst353_read_config(esp_lcd_touch_handle_t tp);

esp_err_t esp_lcd_touch_new_i2c_cst353(const esp_lcd_panel_io_handle_t io, const esp_lcd_touch_config_t *config,
                                       esp_lcd_touch_handle_t *out_touch)
{
    esp_err_t ret                 = ESP_OK;
    esp_lcd_touch_handle_t cst353 = NULL;

    ESP_RETURN_ON_FALSE(io && config && out_touch, ESP_ERR_INVALID_ARG, TAG, "Invalid arguments");

    /* Allocate memory for controller */
    cst353 = heap_caps_calloc(1, sizeof(esp_lcd_touch_t), MALLOC_CAP_DEFAULT);
    ESP_RETURN_ON_FALSE(cst353, ESP_ERR_NO_MEM, TAG, "No memory for CST353");

    /* Communication interface */
    cst353->io = io;

    /* Set callbacks */
    cst353->read_data = esp_lcd_touch_cst353_read_data;
    cst353->get_xy    = esp_lcd_touch_cst353_get_xy;
    cst353->del       = esp_lcd_touch_cst353_del;

    /* Mutex init */
    cst353->data.lock.owner = portMUX_FREE_VAL;

    /* Save config */
    memcpy(&cst353->config, config, sizeof(esp_lcd_touch_config_t));

    /* Initialize reset GPIO */
    if (cst353->config.rst_gpio_num != GPIO_NUM_NC) {
        gpio_config_t rst_gpio_cfg = {
            .pin_bit_mask = BIT64(cst353->config.rst_gpio_num),
            .mode         = GPIO_MODE_OUTPUT,
        };
        ESP_GOTO_ON_ERROR(gpio_config(&rst_gpio_cfg), err, TAG, "GPIO config failed");
    }

    /* Hardware reset */
    ESP_GOTO_ON_ERROR(cst353_reset(cst353), err, TAG, "Reset failed");

    /* Read chip configuration */
    ESP_GOTO_ON_ERROR(cst353_read_config(cst353), err, TAG, "Read config failed");

    /* Prepare pin for touch interrupt */
    if (cst353->config.int_gpio_num != GPIO_NUM_NC) {
        printf("\n===================\n");
        printf("\nadd touch interrupt\n");
        const gpio_config_t int_gpio_config = {
            .mode = GPIO_MODE_INPUT,
            .intr_type = (cst353->config.levels.interrupt ? GPIO_INTR_POSEDGE : GPIO_INTR_NEGEDGE),
            .pin_bit_mask = BIT64(cst353->config.int_gpio_num)
        };
        ret = gpio_config(&int_gpio_config);
        ESP_GOTO_ON_ERROR(ret, err, TAG, "GPIO config failed");

        /* Register interrupt callback */
        if (cst353->config.interrupt_callback) {
            esp_lcd_touch_register_interrupt_callback(cst353, cst353->config.interrupt_callback);
        }
    }

    *out_touch = cst353;
    return ESP_OK;

err:
    if (cst353) {
        esp_lcd_touch_cst353_del(cst353);
    }
    return ret;
}

static esp_err_t esp_lcd_touch_cst353_read_data(esp_lcd_touch_handle_t tp)
{
    uint8_t data[50] = {0};
    esp_err_t ret    = ESP_OK;
    uint8_t finger_num, key_num;

    // read tp info
    ret = cst353_read_reg(tp, 0xD0070000, 4, data, 9); // 每个触摸点 9 bytes 数据
    if (ret != ESP_OK) {
        goto err;
    }
    // for (uint8_t i = 0; i < 9; i++) {
    //     printf("%#x ", data[i]);
    // }
    // printf("\n");

    finger_num = data[3] & 0x0F;
    key_num    = (data[3] & 0xF0) >> 4;
    if (key_num + finger_num > 1) {  // 若大于1个触摸点，则继续读取数据
        esp_lcd_panel_io_rx_param(tp->io, 0x00, &data[9], (key_num + finger_num - 1) * 5);
    }

    // End of report
    ret = cst353_write_reg_nd(tp, 0xD00002AB, 4);
    if (ret != ESP_OK) {
        printf(" End of report error\n");
    }

    uint8_t points = finger_num;
    points         = (points > CST353_MAX_TOUCH_POINTS) ? CST353_MAX_TOUCH_POINTS : points;

    uint8_t key_state = data[8] >> 4;
    portENTER_CRITICAL(&tp->data.lock);

    tp->data.points = 0;
    if (finger_num) {
        uint16_t index = 0;
        int pos_x, pos_y;
        for (uint8_t i = 0; i < finger_num; i++) {
            index                = (key_num + i) * 5;
            pos_x                = data[index + 4] + ((uint16_t)(data[index + 7] & 0x0F) << 8);
            pos_y                = data[index + 5] + ((uint16_t)(data[index + 7] & 0xF0) << 4);
            tp->data.coords[i].x = pos_x;
            tp->data.coords[i].y = pos_y;
            //tp->data.points++;
           // ESP_LOGV(TAG, "Point %d: X=%d, Y=%d", i, tp->data.coords[i].x, tp->data.coords[i].y);
        }
    }
    tp->data.points = (key_state != 0) ? 1 : 0;
    portEXIT_CRITICAL(&tp->data.lock);

    //ESP_LOGI(TAG, "Point %d: X=%d, Y=%d", 0, tp->data.coords[0].x, tp->data.coords[0].y);

    return ret;

err:
    if (tp->config.rst_gpio_num != GPIO_NUM_NC) {
        gpio_set_level(tp->config.rst_gpio_num, 0);
        vTaskDelay(pdMS_TO_TICKS(10));
        gpio_set_level(tp->config.rst_gpio_num, 1);
        vTaskDelay(pdMS_TO_TICKS(50));
    }
    return ESP_FAIL;
}

static bool esp_lcd_touch_cst353_get_xy(esp_lcd_touch_handle_t tp, uint16_t *x, uint16_t *y, uint16_t *strength,
                                        uint8_t *point_num, uint8_t max_point_num)
{
    assert(tp && x && y && point_num);

    portENTER_CRITICAL(&tp->data.lock);
    *point_num = (tp->data.points > max_point_num) ? max_point_num : tp->data.points;

    for (size_t i = 0; i < *point_num; i++) {
        x[i] = tp->data.coords[i].x;
        y[i] = tp->data.coords[i].y;
        if (strength) strength[i] = 1; /* Strength not supported */
    }

    portEXIT_CRITICAL(&tp->data.lock);
    return (*point_num > 0);
}

static esp_err_t esp_lcd_touch_cst353_del(esp_lcd_touch_handle_t tp)
{
    if (tp->config.rst_gpio_num != GPIO_NUM_NC) {
        gpio_reset_pin(tp->config.rst_gpio_num);
    }
    if (tp->config.int_gpio_num != GPIO_NUM_NC) {
        gpio_reset_pin(tp->config.int_gpio_num);
    }
    free(tp);
    return ESP_OK;
}

static esp_err_t cst353_reset(esp_lcd_touch_handle_t tp)
{
    if (tp->config.rst_gpio_num != GPIO_NUM_NC) {
        ESP_RETURN_ON_ERROR(gpio_set_level(tp->config.rst_gpio_num, 0), TAG, "Reset low failed");
        vTaskDelay(pdMS_TO_TICKS(10));
        ESP_RETURN_ON_ERROR(gpio_set_level(tp->config.rst_gpio_num, 1), TAG, "Reset high failed");
        vTaskDelay(pdMS_TO_TICKS(50));
    }
    return ESP_OK;
}

static esp_err_t cst353_read_config(esp_lcd_touch_handle_t tp)
{
    esp_err_t ret = ESP_OK;

    // disable lp scan
    cst353_write_reg_nd(tp, 0xD0000400, 4);
    vTaskDelay(pdMS_TO_TICKS(20));
    cst353_write_reg_nd(tp, 0xD0000400, 4);
    vTaskDelay(pdMS_TO_TICKS(20));

    // normal mode, normal report, normal report
    uint32_t regs[] = {0xD0000000, 0xD0000C00, 0xD0000100};
    for (int i = 0; i < 3; i++) {
        cst353_write_reg_nd(tp, regs[i], 4);
    }

    // read config info
    uint8_t buf[50];
    cst353_read_reg(tp, 0xD0030000, 4, buf, 50);

#define U8TO16(low, high)  (((uint16_t)(high) << 8) | (low))
#define U8TO32(a, b, c, d) (((uint32_t)(a) << 24) | ((uint32_t)(b) << 16) | ((uint32_t)(c) << 8) | (d))

    uint8_t tx          = buf[48];
    uint8_t rx          = buf[49];
    uint8_t key         = buf[27];
    uint16_t res_x      = U8TO16(buf[28], buf[29]);
    uint16_t res_y      = U8TO16(buf[30], buf[31]);
    uint32_t project_id = U8TO32(buf[39], buf[38], buf[37], buf[36]);
    uint32_t chip_type  = U8TO32(buf[3], buf[2], buf[1], buf[0]);
    uint32_t fw_ver     = U8TO32(buf[35], buf[34], buf[33], buf[32]);
    uint16_t checksum   = U8TO16(buf[44], buf[45]);

    ESP_LOGI(TAG, "触摸驱动配置信息：");
    ESP_LOGI(TAG, "  通道数  -> TX: %d, RX: %d, 按键数: %d", tx, rx, key);
    ESP_LOGI(TAG, "  分辨率  -> X: %d, Y: %d", res_x, res_y);
    ESP_LOGI(TAG, "  项目 ID -> 0x%08lX", project_id);
    ESP_LOGI(TAG, "  芯片 ID -> 0x%08lX", chip_type);
    ESP_LOGI(TAG, "  FW版本  -> 0x%08lX", fw_ver);
    ESP_LOGI(TAG, "  校验值  -> 0x%08X", checksum);

    return ret;
}

/**
 * 无数据
 */
static esp_err_t cst353_write_reg_nd(esp_lcd_touch_handle_t tp, uint32_t reg, size_t reg_len)
{
    if (reg_len == 0 || reg_len > 4) {
        return ESP_ERR_INVALID_ARG;
    }

    uint8_t addr_buf[4];
    for (int i = 0; i < reg_len; i++) {
        addr_buf[reg_len - 1 - i] = (reg >> (i * 8)) & 0xFF;
    }

    return esp_lcd_panel_io_tx_param(tp->io, addr_buf[0], &addr_buf[1], reg_len - 1);
}

static esp_err_t cst353_read_reg(esp_lcd_touch_handle_t tp, uint32_t reg, size_t reg_len, uint8_t *read_buf,
                                 size_t read_len)
{
    if (reg_len == 0 || reg_len > 4 || read_len == 0 || read_buf == NULL) {
        return ESP_ERR_INVALID_ARG;
    }

    uint8_t addr_buf[4];
    for (int i = 0; i < reg_len; i++) {
        addr_buf[reg_len - 1 - i] = (reg >> (i * 8)) & 0xFF;
    }

    esp_err_t err = esp_lcd_panel_io_tx_param(tp->io, addr_buf[0], &addr_buf[1], reg_len - 1);
    if (err != ESP_OK) return err;
    return esp_lcd_panel_io_rx_param(tp->io, 0x00, read_buf, read_len);
}

```